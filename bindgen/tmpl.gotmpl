// Code generated by bindgen, DO NOT EDIT.

package {{.package}}

import "github.com/newalchemylimited/seth"

{{range $c := .contracts}}

	type {{$c.Name}} struct {
		addr  *seth.Address
		s     *seth.Sender
	}

	func New{{$c.Name}}(addr *seth.Address, sender *seth.Sender) *{{$c.Name}} {
		return &{{$c.Name}}{addr: addr, s: sender}
	}

	{{range $d := $c.ABI}}
		
		{{if eq $d.Type "function" }}

			{{if $d.Constant}}

				// {{FuncName $d.Name}} calls the solidity view {{$c.Name}}.{{$d.Signature}}
				func (c *{{$c.Name}}) {{FuncName $d.Name}}({{range $i, $input := $d.Inputs}}{{if gt $i 0}}, {{end}}{{ArgName $input.Name}} {{ArgType $input.Type}}{{end}}) ({{range $i, $output := $d.Outputs}}{{ArgName $output.Name}} {{RetType $output.Type}}, {{end}}err error) {
					d := seth.NewABIDecoder({{range $i, $output := $d.Outputs}}{{if gt $i 0}}, {{end}}&{{ArgName $output.Name}}{{end}})
					err = c.s.ConstCall(c.addr, "{{$d.Signature}}", d{{range $i, $input := $d.Inputs}}, {{ArgName $input.Name}}{{end}})
					return
				}
			
			{{else}}

				// {{FuncName $d.Name}} calls the solidity function {{$c.Name}}.{{$d.Signature}}
				func (c *{{$c.Name}}) {{FuncName $d.Name}}({{range $i, $input := $d.Inputs}}{{if gt $i 0}}, {{end}}{{ArgName $input.Name}} {{ArgType $input.Type}}{{end}}) (res seth.Hash, err error) {
					return c.s.Send(c.addr, "{{$d.Signature}}"{{range $i, $input := $d.Inputs}}, {{ArgName $input.Name}}{{end}})
				}

			{{end}}

		{{end}}

		{{if eq $d.Type "event" }}

			type {{FuncName $d.Name}}Event struct {
				Log *seth.Log{{range $i, $input := $d.Inputs}}
					{{ArgNameUpper $input.Name}} {{ArgType $input.Type}}{{end}}
			}

			func (e *{{FuncName $d.Name}}Event) FromABI(data []byte) error {
				return seth.DecodeABI(data{{range $i, $input := $d.Inputs}}, &e.{{ArgNameUpper $input.Name}}{{end}})
			}

			func (c *Test) Filter{{FuncName $d.Name}}Event(start, end int64) (outChan chan *{{FuncName $d.Name}}Event, close func(), errChan chan error) {
				errChan = make(chan error)

				topic := seth.HashString("{{$d.Signature}}")
				filter, err := c.s.FilterTopics([]*seth.Hash{&topic}, c.addr, start, end)
				if err != nil {
					go func() {
						errChan <- err
					}()
					return
				}

				outChan = make(chan *{{FuncName $d.Name}}Event)
				close = filter.Close

				go func() {
					defer filter.Close()
					for {
						if filter.Err() != nil {
							errChan <- err
							return
						}
						select {
						case msg := <-filter.Out():
							if msg == nil {
								outChan <- nil
								return
							}

							x := &{{FuncName $d.Name}}Event{
								Log: msg,
							}
							if err := x.FromABI(msg.Data); err != nil {
								errChan <- err
								return
							}
							outChan <- x
						}
					}
				}()

				return
			}
		{{end}}

	{{end}}
	

{{end}}


{{range $c := .contracts}}

	var {{$c.Name}}Code = {{CodeVar $c.Code}}

{{end}}